// Code generated by protoc-gen-pico. DO NOT EDIT.
// source: types.proto
//
// versions:
//     protoc-gen-pico: (devel)
//     protoc:          v3.17.3

package protocompat

import (
	picobuf "storj.io/picobuf"
)

type LanguagePico int32

const (
	Language_UNKNOWNPico LanguagePico = 0
	Language_ENGLISHPico LanguagePico = 1
	Language_SPANISHPico LanguagePico = 3
	Language_FRENCHPico  LanguagePico = 4
	Language_GERMANPico  LanguagePico = 5
)

type TypesPico struct {
	Int32           int32
	Int64           int64
	Uint32          uint32
	Uint64          uint64
	Sint32          int32
	Sint64          int64
	Fixed32         uint32
	Fixed64         uint64
	Sfixed32        int32
	Sfixed64        int64
	Float           float32
	Double          float64
	Bool            bool
	String_         string
	Bytes           []byte
	Message         MessagePico
	OptionalMessage *OptionalMessagePico
	Language        LanguagePico
}

func (m *TypesPico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.Int32(1, &m.Int32)
	c.Int64(2, &m.Int64)
	c.Uint32(3, &m.Uint32)
	c.Uint64(4, &m.Uint64)
	c.Sint32(5, &m.Sint32)
	c.Sint64(6, &m.Sint64)
	c.Fixed32(7, &m.Fixed32)
	c.Fixed64(8, &m.Fixed64)
	c.Sfixed32(9, &m.Sfixed32)
	c.Sfixed64(10, &m.Sfixed64)
	c.Float(11, &m.Float)
	c.Double(12, &m.Double)
	c.Bool(13, &m.Bool)
	c.String(14, &m.String_)
	c.Bytes(15, &m.Bytes)
	c.PresentMessage(16, m.Message.Encode)
	c.Message(17, m.OptionalMessage.Encode)
	c.Int32(18, (*int32)(&m.Language))
	return true
}

func (m *TypesPico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.Int32(1, &m.Int32)
	c.Int64(2, &m.Int64)
	c.Uint32(3, &m.Uint32)
	c.Uint64(4, &m.Uint64)
	c.Sint32(5, &m.Sint32)
	c.Sint64(6, &m.Sint64)
	c.Fixed32(7, &m.Fixed32)
	c.Fixed64(8, &m.Fixed64)
	c.Sfixed32(9, &m.Sfixed32)
	c.Sfixed64(10, &m.Sfixed64)
	c.Float(11, &m.Float)
	c.Double(12, &m.Double)
	c.Bool(13, &m.Bool)
	c.String(14, &m.String_)
	c.Bytes(15, &m.Bytes)
	c.PresentMessage(16, m.Message.Decode)
	c.Message(17, func(c *picobuf.Decoder) {
		if m.OptionalMessage == nil {
			m.OptionalMessage = new(OptionalMessagePico)
		}
		m.OptionalMessage.Decode(c)
	})
	c.Int32(18, (*int32)(&m.Language))
}

type RepeatedTypesPico struct {
	Int32    []int32
	Int64    []int64
	Uint32   []uint32
	Uint64   []uint64
	Sint32   []int32
	Sint64   []int64
	Fixed32  []uint32
	Fixed64  []uint64
	Sfixed32 []int32
	Sfixed64 []int64
	Float    []float32
	Double   []float64
	Bool     []bool
	String_  []string
	Bytes    [][]byte
	Message  []*MessagePico
	Language []LanguagePico
}

func (m *RepeatedTypesPico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.RepeatedInt32(1, &m.Int32)
	c.RepeatedInt64(2, &m.Int64)
	c.RepeatedUint32(3, &m.Uint32)
	c.RepeatedUint64(4, &m.Uint64)
	c.RepeatedSint32(5, &m.Sint32)
	c.RepeatedSint64(6, &m.Sint64)
	c.RepeatedFixed32(7, &m.Fixed32)
	c.RepeatedFixed64(8, &m.Fixed64)
	c.RepeatedSfixed32(9, &m.Sfixed32)
	c.RepeatedSfixed64(10, &m.Sfixed64)
	c.RepeatedFloat(11, &m.Float)
	c.RepeatedDouble(12, &m.Double)
	c.RepeatedBool(13, &m.Bool)
	c.RepeatedString(14, &m.String_)
	c.RepeatedBytes(15, &m.Bytes)
	for _, x := range m.Message {
		c.AlwaysMessage(16, x.Encode)
	}
	c.RepeatedEnum(17, len(m.Language), func(index int) int32 {
		return (int32)(m.Language[index])
	})
	return true
}

func (m *RepeatedTypesPico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.RepeatedInt32(1, &m.Int32)
	c.RepeatedInt64(2, &m.Int64)
	c.RepeatedUint32(3, &m.Uint32)
	c.RepeatedUint64(4, &m.Uint64)
	c.RepeatedSint32(5, &m.Sint32)
	c.RepeatedSint64(6, &m.Sint64)
	c.RepeatedFixed32(7, &m.Fixed32)
	c.RepeatedFixed64(8, &m.Fixed64)
	c.RepeatedSfixed32(9, &m.Sfixed32)
	c.RepeatedSfixed64(10, &m.Sfixed64)
	c.RepeatedFloat(11, &m.Float)
	c.RepeatedDouble(12, &m.Double)
	c.RepeatedBool(13, &m.Bool)
	c.RepeatedString(14, &m.String_)
	c.RepeatedBytes(15, &m.Bytes)
	c.RepeatedMessage(16, func(c *picobuf.Decoder) {
		mm := new(MessagePico)
		c.Loop(mm.Decode)
		m.Message = append(m.Message, mm)
	})
	c.RepeatedEnum(17, func(x int32) {
		m.Language = append(m.Language, (LanguagePico)(x))
	})
}

type RepeatedMixedPico struct {
	Int32   int32
	Message []*MessagePico
}

func (m *RepeatedMixedPico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.Int32(1, &m.Int32)
	for _, x := range m.Message {
		c.AlwaysMessage(16, x.Encode)
	}
	return true
}

func (m *RepeatedMixedPico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.Int32(1, &m.Int32)
	c.RepeatedMessage(16, func(c *picobuf.Decoder) {
		mm := new(MessagePico)
		c.Loop(mm.Decode)
		m.Message = append(m.Message, mm)
	})
}

type MessagePico struct {
	Int32 int32
	Int64 int64
}

func (m *MessagePico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.Int32(1, &m.Int32)
	c.Int64(2, &m.Int64)
	return true
}

func (m *MessagePico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.Int32(1, &m.Int32)
	c.Int64(2, &m.Int64)
}

type PersonPico struct {
	Name     string
	Birthday int64
	Phone    string
	Siblings int32
	Spouse   bool
	Money    float64
	Primary  LanguagePico
	Spoken   []LanguagePico
}

func (m *PersonPico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.String(1, &m.Name)
	c.Int64(2, &m.Birthday)
	c.String(3, &m.Phone)
	c.Int32(4, &m.Siblings)
	c.Bool(5, &m.Spouse)
	c.Double(6, &m.Money)
	c.Int32(7, (*int32)(&m.Primary))
	c.RepeatedEnum(8, len(m.Spoken), func(index int) int32 {
		return (int32)(m.Spoken[index])
	})
	return true
}

func (m *PersonPico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.String(1, &m.Name)
	c.Int64(2, &m.Birthday)
	c.String(3, &m.Phone)
	c.Int32(4, &m.Siblings)
	c.Bool(5, &m.Spouse)
	c.Double(6, &m.Money)
	c.Int32(7, (*int32)(&m.Primary))
	c.RepeatedEnum(8, func(x int32) {
		m.Spoken = append(m.Spoken, (LanguagePico)(x))
	})
}

type MapPico struct {
	Values map[string]string
}

func (m *MapPico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.MapStringString(1, &m.Values)
	return true
}

func (m *MapPico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.MapStringString(1, &m.Values)
}

type OptionalMessagePico struct {
	Int32 int32
}

func (m *OptionalMessagePico) Encode(c *picobuf.Encoder) bool {
	if m == nil {
		return false
	}
	c.Int32(1, &m.Int32)
	return true
}

func (m *OptionalMessagePico) Decode(c *picobuf.Decoder) {
	if m == nil {
		return
	}
	c.Int32(1, &m.Int32)
}
