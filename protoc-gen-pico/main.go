// Copyright (C) 2021 Storj Labs, Inc.
// See LICENSE for copying information.

package main

import (
	"flag"
	"fmt"
	"runtime/debug"
	"sort"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	picobufPackage     = protogen.GoImportPath("storj.io/picobuf")
	timestamppbPackage = protogen.GoImportPath("google.golang.org/protobuf/types/known/timestamppb")
)

type config struct {
	suffix string
}

func main() {
	var flags flag.FlagSet
	var conf config
	flags.StringVar(&conf.suffix, "suffix", "", "Suffix to apply to all package level identifiers")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if f.Generate {
				genFile(plugin, f, conf)
			}
		}
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		return nil
	})
}

type generator struct {
	*protogen.GeneratedFile
	*protogen.File
	suffix string
}

func genFile(plugin *protogen.Plugin, file *protogen.File, conf config) {
	gf := &generator{
		GeneratedFile: plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".pico.go", file.GoImportPath),
		File:          file,
		suffix:        conf.suffix,
	}

	gf.P("// Code generated by protoc-gen-pico. DO NOT EDIT.")
	gf.P("// source: ", file.Desc.Path())
	gf.P("//")
	gf.P("// versions:")
	{
		picoVersion := "(unknown)"
		if bi, ok := debug.ReadBuildInfo(); ok {
			picoVersion = bi.Main.Version
		}
		gf.P("//     protoc-gen-pico: ", picoVersion)
	}
	{
		protocVersion := "(unknown)"
		if v := plugin.Request.GetCompilerVersion(); v != nil {
			protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
			if s := v.GetSuffix(); s != "" {
				protocVersion += "-" + s
			}
		}
		gf.P("//     protoc:          ", protocVersion)
	}
	gf.P()
	gf.P("package ", file.GoPackageName)
	gf.P()

	genWalk(gf, file, file.Enums, file.Messages)
}

func genWalk(gf *generator, file *protogen.File, enums []*protogen.Enum, msgs []*protogen.Message) {
	for _, e := range enums {
		genEnum(gf, e)
	}
	for _, m := range msgs {
		genMessage(gf, m)
	}
	for _, m := range msgs {
		genWalk(gf, file, m.Enums, m.Messages)
	}
}

func genEnum(gf *generator, e *protogen.Enum) {
	gf.P("type ", e.GoIdent, gf.suffix, " int32")

	gf.P("const (")
	for _, v := range e.Values {
		gf.P(v.GoIdent, gf.suffix, " ", e.GoIdent, gf.suffix, " = ", v.Desc.Number())
	}
	gf.P(")")

	gf.P()
}

func genMessage(gf *generator, m *protogen.Message) {
	if m.Desc.IsMapEntry() {
		return
	}

	gf.P("type ", m.GoIdent, gf.suffix, " struct {")
	for _, field := range m.Fields {
		genMessageField(gf, m, field)
	}
	gf.P("}")

	gf.P()

	genMessageMethods(gf, m)
	genMessageOneofWrapperTypes(gf, m)
}

func genMessageField(gf *generator, m *protogen.Message, field *protogen.Field) {
	if field.Desc.IsWeak() {
		panic("unhandled: weak field")
	}
	if field.Desc.HasDefault() {
		panic("unsupported: default values")
	}

	if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
		if oneof.Fields[0] != field {
			return // only generate for first appearance
		}
		gf.P(oneof.GoName, " ", oneofInterfaceName(gf, oneof))
		return
	}

	gf.P(field.GoName, " ", fieldGoType(gf, field))
}

func oneofInterfaceName(gf *generator, oneof *protogen.Oneof) string {
	return "is" + oneof.GoIdent.GoName + gf.suffix
}

func genMessageMethods(gf *generator, m *protogen.Message) {
	gf.P("func (m *", m.GoIdent, gf.suffix, ") Picobuf(c *", picobufPackage.Ident("Codec"), ") bool {")
	gf.P("if m == nil { return false }")

	fields := append([]*protogen.Field(nil), m.Fields...)
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].Desc.Number() < fields[j].Desc.Number()
	})

	for _, field := range fields {
		method := codecMethodName(gf, field)
		if method == "Message" {
			gf.P("c.Message(", field.Desc.Number(), ", func(c *", picobufPackage.Ident("Codec"), ") bool {")
			gf.P("  if c.IsDecoding() && m.", field.GoName, " == nil {")
			gf.P("    m.", field.GoName, " = new(", fieldGoType(gf, field)[1:], ")")
			gf.P("  }")
			gf.P("  return m.", field.GoName, ".Picobuf(c)")
			gf.P("})")
		} else {
			gf.P("c.", method, "(", field.Desc.Number(), ", &m.", field.GoName, ")")
		}
	}
	gf.P("return true")
	gf.P("}")
	gf.P()
}

func codecMethodName(gf *generator, field *protogen.Field) string {
	if method, ok := methodNames[field.Desc.Kind()]; ok {
		if field.Desc.IsList() {
			method = "Repeated" + method
		}
		return method
	}
	panic(fmt.Sprintf("unhandled: invalid field kind: %v", field.Desc.Kind()))
}

var methodNames = map[protoreflect.Kind]string{
	protoreflect.BoolKind:     "Bool",
	protoreflect.Int32Kind:    "Int32",
	protoreflect.Int64Kind:    "Int64",
	protoreflect.Uint32Kind:   "Uint32",
	protoreflect.Uint64Kind:   "Uint64",
	protoreflect.Sint32Kind:   "Sint32",
	protoreflect.Sint64Kind:   "Sint64",
	protoreflect.Fixed32Kind:  "Fixed32",
	protoreflect.Fixed64Kind:  "Fixed64",
	protoreflect.Sfixed32Kind: "Sfixed32",
	protoreflect.Sfixed64Kind: "Sfixed64",
	protoreflect.FloatKind:    "Float",
	protoreflect.DoubleKind:   "Double",
	protoreflect.StringKind:   "String",
	protoreflect.BytesKind:    "Bytes",
	protoreflect.EnumKind:     "Int32",
	protoreflect.MessageKind:  "Message",
}

func fieldGoType(gf *generator, field *protogen.Field) (goType string) {
	if field.Desc.IsWeak() {
		panic("unhandled: weak field")
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = gf.QualifiedGoIdent(field.Enum.GoIdent)
		if field.Enum.GoIdent.GoImportPath == gf.GoImportPath {
			goType += gf.suffix
		}
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
	case protoreflect.MessageKind:
		// intercept the well-known timestamp type to be our own type
		switch field.Message.GoIdent {
		case timestamppbPackage.Ident("Timestamp"):
			goType = "picobuf.Timestamp"
		default:
			goType = gf.QualifiedGoIdent(field.Message.GoIdent)
			if field.Message.GoIdent.GoImportPath == gf.GoImportPath {
				goType += gf.suffix
			}
		}
	default:
		panic(fmt.Sprintf("unhandled: invalid field kind: %v", field.Desc.Kind()))
	}

	switch {
	case field.Desc.IsList():
		return "[]" + goType
	case field.Desc.IsMap():
		panic("unhandled: map field types")
	}

	if field.Desc.HasPresence() {
		return "*" + goType
	}
	return goType
}

func genMessageOneofWrapperTypes(gf *generator, m *protogen.Message) {
	for _, oneof := range m.Oneofs {
		if oneof.Desc.IsSynthetic() {
			continue
		}
		ifName := oneofInterfaceName(gf, oneof)

		gf.P("type ", ifName, " interface {", ifName, "() }")
		gf.P()

		for _, field := range oneof.Fields {
			gf.P("type ", field.GoIdent, gf.suffix, " struct {")
			gf.P(field.GoName, " ", fieldGoType(gf, field))
			gf.P("}")
			gf.P()
		}
		gf.P()

		for _, field := range oneof.Fields {
			gf.P("func (*", field.GoIdent, gf.suffix, ") ", ifName, "() {}")
		}
		gf.P()
	}
}
